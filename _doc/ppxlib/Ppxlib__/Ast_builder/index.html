<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ast_builder (ppxlib.Ppxlib__.Ast_builder)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">ppxlib</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Ppxlib__.Ast_builder</span></h1></header><p>Helpers for build OCaml AST fragments</p><p>This module is similar to the <code class="code">Ast_helper</code> module distrubuted with OCaml but uses
different conventions.</p><h4>Locations</h4><p><code class="code">Ast_helper</code> uses a global variable for the default locations, we found that to it
makes it quite easy to mess up locations. Instead this modules forces you to provide a
location argument.</p><p>For building fragment using the same location everywhere, a functor is provided.</p><h4>Naming</h4><p>The names match the <code class="code">Parsetree</code> names closely, which makes it easy to build AST
fragments by just knowing the <code class="code">Parsetree</code>.</p><p>For types of the form a wrapper record with a <code class="code">_desc</code> field, helpers are generated for
each constructor constructing the record directly. For instance for the type
<code class="code">Parsetree.expression</code>:</p><pre><code class="code">      type expression =
        { pexp_desc       : expression_desc
        ; pexp_loc        : Location.t
        ; pexp_attributes : attributes
        }

      and expression_desc =
        | Pexp_ident    of Longident.t loc
        | Pexp_constant of constant
        | Pexp_let      of rec_flag * value_binding list * expression
        ...</code></pre><p>The following helpers are created:</p><pre><code class="code">      val pexp_ident    : loc:Location.t -&gt; Longident.t Located.t          -&gt; expression
      val pexp_constant : loc:Location.t -&gt; constant                       -&gt; expression
      val pexp_let      : loc:Location.t -&gt; rec_flag -&gt; value_binding list -&gt; expression
      ...</code></pre><p>For other record types, such as type_declaration, we have the following helper:</p><pre><code class="code">      type type_declaration =
        { ptype_name       : string Located.t
        ; ptype_params     : (core_type * variance) list
        ; ptype_cstrs      : (core_type * core_type * Location.t) list
        ; ptype_kind       : type_kind
        ; ptype_private    : private_flag
        ; ptype_manifest   : core_type option
        ; ptype_attributes : attributes
        ; ptype_loc        : Location.t
        }


      val type_declaration
        :  loc      : Location.t
        -&gt; name     : string Located.t
        -&gt; params   : (core_type * variance) list
        -&gt; cstrs    : (core_type * core_type * Location.t) list
        -&gt; kind     : type_kind
        -&gt; private  : private_flag
        -&gt; manifest : core_type option
        -&gt; type_declaration</code></pre><p>Attributes are always set to the empty list. If you want to set them you have to
override the field with the <code class="code">{ e with pexp_attributes = ... }</code> notation.</p><div class="spec module" id="module-Default"><a href="#module-Default" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Default/index.html">Default</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"><p>Helpers taking a <code class="code">~loc</code> argument. This module is meant to be opened or aliased.</p></div></div><div class="spec module-type" id="module-type-Loc"><a href="#module-type-Loc" class="anchor"></a><div class="def module-type"><code><span class="keyword">module type </span>Loc = <a href="../Ast_builder_intf/index.html#module-type-Loc">Ppxlib__.Ast_builder_intf.Loc</a></code></div><div class="doc"></div></div><div class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><div class="def module-type"><code><span class="keyword">module type </span>S = <a href="../Ast_builder_intf/index.html#module-type-S">Ppxlib__.Ast_builder_intf.S</a></code></div><div class="doc"></div></div><div class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><div class="def module"><code><span class="keyword">module </span>Make : <span class="keyword">functor</span> (<a href="Make/index.html#argument-1-Loc">Loc</a> : <a href="index.html#module-type-Loc">Loc</a>) -&gt; <a href="index.html#module-type-S">S</a></code></div><div class="doc"><p>Build Ast helpers with the location argument factorized.</p></div></div><div class="spec val" id="val-make"><a href="#val-make" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>make : <a href="../../Ppxlib/Location/index.html#type-t">Ppxlib.Location.t</a> <span class="keyword">&#8209;&gt;</span> (<span class="keyword">module </span><a href="module-type-S/index.html">S</a>)</code></div><div class="doc"><p>Functional version of <code class="code">Make</code>.</p></div></div></body></html>