<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>good-practices (ppxlib.good-practices)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> – <a href="index.html">ppxlib</a> &#x00BB; good-practices</nav><header class="odoc-preamble"><p> <div style="display: flex; justify-content:space-between"><div><a href="ast-traversal.html">&lt; Traversing the AST</a> </div><div><a href="examples.html">Examples &gt;</a> </div></div></p><h1 id="good-practices"><a href="#good-practices" class="anchor"></a>Good Practices</h1></header><nav class="odoc-toc"><ul><li><a href="#resp_loc">Respecting Locations</a><ul><li><a href="#the-invariants">The Invariants</a></li><li><a href="#guidelines-for-writing-well-behaved-ppxs">Guidelines for Writing Well-Behaved PPXs</a></li></ul></li><li><a href="#handling_errors">Handling Errors</a><ul><li><a href="#embedding-the-errors-in-the-ast">Embedding the Errors in the AST</a></li><li><a href="#a-documented-example">A Documented Example</a></li><li><a href="#in-case-of-panic">In Case of Panic</a></li><li><a href="#migrating-from-raising-to-embedding-errors">Migrating From Raising to Embedding Errors</a></li></ul></li><li><a href="#quoting">Quoting</a></li><li><a href="#testing-your-ppx">Testing Your PPX</a></li><li><a href="#migrate-from-other-preprocessing-systems">Migrate From Other Preprocessing Systems</a></li><li><a href="#other-good-practices">Other good practices</a></li></ul></nav><div class="odoc-content"><h2 id="resp_loc"><a href="#resp_loc" class="anchor"></a>Respecting Locations</h2><p>Correctly dealing with location is essential to correctly generate OCaml code. They are necessary for error reporting by the compiler, but more generally for Merlin's features to work, such as displaying occurrences and jumping to definition. When called, the driver is called with the <code>-check</code> and <code>-check-locations</code> flags, <code>ppxlib</code> makes it is a requirement that locations follow some rules in order to accept the rewriting, as it will check that some invariants are respected.</p><h3 id="the-invariants"><a href="#the-invariants" class="anchor"></a>The Invariants</h3><p>The invariants are as follows:</p><ul><li>AST nodes are requested to be well-nested WRT locations</li><li>the locations of &quot;sibling&quot; AST nodes should not overlap</li></ul><p>This is required for Merlin to behave properly.</p><p>Indeed, for almost any query directed at Merlin, it will need to inspect the context around the user's cursor to give an answer that makes sense. And the only input it has to do that is the cursor’s position in the buffer. The handling of most queries starts by traversing the AST, using the locations of nodes to select the right branch. (1) is necessary to avoid discarding subtrees too early, (2) is used to avoid Merlin making arbitrary choices (if you ask for the type under the cursor, and there seems to be two things under the cursor, Merlin will need to pick one).</p><h3 id="guidelines-for-writing-well-behaved-ppxs"><a href="#guidelines-for-writing-well-behaved-ppxs" class="anchor"></a>Guidelines for Writing Well-Behaved PPXs</h3><p>It's obviously not always (indeed rarely) possible to mint new locations when manipulating the AST.</p><p>The intended way to deal with locations is this:</p><ul><li>AST nodes that exist in the source should keep their original location</li><li>new nodes should be given a &quot;ghost&quot; location (i.e., <code>{ some_loc with loc_ghost = true }</code>) to indicate that the node doesn't exist in the sources.</li></ul><p>In particular, <a href="Ppxlib/Location/index.html#val-none"><code>Location.none</code></a> is never meant to be used by PPX authors, where some location is always available (for instance, derivers and extenders at least know the locations of their relevant node).</p><p>Both the new check and Merlin will happily traverse the ghost nodes as if they didn't exist. Note: this comes into play when deciding which nodes are &quot;siblings,&quot; for instance, if your AST is:</p><pre>  A (B1(C, D),
     B2(X, Y))</pre><p>but <code>B2</code> has a ghost location, then <code>B1</code>, <code>X</code> and <code>Y</code> are considered siblings.</p><p>Additionally, there is an attribute <code>[@merlin.hide]</code> that you can add on nodes to tell Merlin (and the check) to ignore this node and all of its children. Some helpers for this are provided in <a href="Ppxlib/Merlin_helpers/index.html"><code>Merlin_helpers</code></a>.</p><h2 id="handling_errors"><a href="#handling_errors" class="anchor"></a>Handling Errors</h2><p>In order to give a nice user experience when reporting errors or failures in a PPX, it is necessary to include as much generated content as possible. Most IDE tools, such as Merlin, rely on the AST for their features, such as displaying type, jumping to definition, or showing the list of errors.</p><h3 id="embedding-the-errors-in-the-ast"><a href="#embedding-the-errors-in-the-ast" class="anchor"></a>Embedding the Errors in the AST</h3><p>A common way to report an error is to throw an exception. However, this method interrupts the execution flow of the <code>ppxlib</code> driver and leaves later PPXs unexpanded when handing the AST over to Merlin.</p><p>Instead, it is better to always return a valid AST, as complete as possible, but with &quot;error extension nodes&quot; at every place where successful code generation was impossible. Error extension nodes are special extension nodes <code>[%ocaml.error
error_message]</code> that can be embedded into a valid AST and are interpreted later as errors, e.g., by the compiler or Merlin. As all extension nodes, they can be put <a href="https://ocaml.org/manual/extensionnodes.html">at many places in the AST</a> to replace structure items, expressions, or patterns, for example.</p><p>So whenever you're in doubt whether to throw an exception or if to embed the error as an error extension node when writing a PPX rewriter, embed the error is the way to go! And whenever you're in doubt about where exactly to embed the error inside the AST, a good ground rule is: as deep in the AST as possible.</p><p>For instance, suppose a rewriter is supposed to define a new record type, but there is an error in one field’s type generation. In order to have the most complete AST as output, the rewriter can still define the type and all of its fields, putting an extension node in place of the type of the faulty field:</p><pre class="language-ocaml"><code>type long_record = {
  field_1: int;
  field_2: [%ocaml.error &quot;field_2 could not be implemented due to foo&quot;];
}</code></pre><p><code>ppxlib</code> provides a function in its API to create error extension nodes: <a href="Ppxlib/Location/index.html#val-error_extensionf"><code>error_extensionf</code></a>. This function creates an extension node, which then must be transformed in the right kind of node using functions such as <a href="Ppxlib/Ast_builder/Default/index.html#val-pexp_extension"><code>pexp_extension</code></a>.</p><h3 id="a-documented-example"><a href="#a-documented-example" class="anchor"></a>A Documented Example</h3><p>Let us give an example. We will define a deriver on types records, which constructs a default value from a given type. For instance, the derivation on the type <code>type t = { x:int; y: float; z: string}</code> would yield <code>let default_t =
{x= 0; y= 0.; z= &quot;&quot;}</code>. This deriver has two limitations:</p><ol><li>It does not work on other types than records,</li><li>It only works for records containing fields of type <code>string</code>, <code>int</code>, or <code>float</code>.</li></ol><p>The rewriter should warn the user about these limitations with a good error reporting. Let’s first look at the second point. Here is the function mapping the fields from the type definition to a default expression.</p><pre class="language-ocaml"><code>let create_record ~loc fields =
  let declaration_to_instantiation (ld : label_declaration) =
    let loc = ld.pld_loc in
    let { pld_type; pld_name; _ } = ld in
    let e =
      match pld_type with
      | { ptyp_desc = Ptyp_constr ({ txt = Lident &quot;string&quot;; _ }, []); _ } -&gt;
          pexp_constant ~loc (Pconst_string (&quot;&quot;, loc, None))
      | { ptyp_desc = Ptyp_constr ({ txt = Lident &quot;int&quot;; _ }, []); _ } -&gt;
          pexp_constant ~loc (Pconst_integer (&quot;0&quot;, None))
      | { ptyp_desc = Ptyp_constr ({ txt = Lident &quot;float&quot;; _ }, []); _ } -&gt;
          pexp_constant ~loc (Pconst_float (&quot;0.&quot;, None))
      | _ -&gt;
          pexp_extension ~loc
          @@ Location.error_extensionf ~loc
               &quot;Default value can only be derived for int, float, and string.&quot;
    in
    ({ txt = Lident pld_name.txt; loc }, e)
  in
  let l = List.map fields ~f:declaration_to_instantiation in
  pexp_record ~loc l None</code></pre><p>When the record definition contains several fields with types other than <code>int</code>, <code>float</code>, or <code>string</code>, several error nodes are added in the AST. Moreover, the location of the error nodes corresponds to the field record's definition. This allows tools such as Merlin to report all errors at once, at the right location, resulting in a better workflow than having to recompile every time an error is corrected to see the next one.</p><p>The first limitation is that the deriver cannot work on non-record types. However, we decided here to derive a default value, even in the case of non-record types, so that it does not appear as undefined in the remaining of the file. This impossible value consists of an error extension node.</p><pre class="language-ocaml"><code>let generate_impl ~ctxt (_rec_flag, type_declarations) =
  let loc = Expansion_context.Deriver.derived_item_loc ctxt in
  List.map type_declarations ~f:(fun (td : type_declaration) -&gt;
      let e, name =
        match td with
        | { ptype_kind = Ptype_record fields; ptype_name; ptype_loc; _ } -&gt;
            (create_record ~loc:ptype_loc fields, ptype_name)
        | { ptype_name; ptype_loc; _ } -&gt;
            ( pexp_extension ~loc
              @@ Location.error_extensionf ~loc:ptype_loc
                   &quot;Cannot derive accessors for non record type %s&quot;
                   ptype_name.txt,
              ptype_name )
      in
      [
        pstr_value ~loc Nonrecursive
          [
            {
              pvb_pat = ppat_var ~loc { txt = &quot;default_&quot; ^ name.txt; loc };
              pvb_expr = e;
              pvb_attributes = [];
              pvb_loc = loc;
            };
          ];
      ])
  |&gt; List.concat</code></pre><h3 id="in-case-of-panic"><a href="#in-case-of-panic" class="anchor"></a>In Case of Panic</h3><p>In some rare cases, it might happen that a whole file rewriter is not able to output a meaningful AST. In this case, they might be tempted to raise a located error: an exception that includes the error's location. Moreover, this has historically been what was suggested to do by <code>ppxlib</code> examples, but it is now discouraged in most of the cases, as it prevents Merlin features to work well.</p><p>If such an exception isn't caught, the PPX driver will return an error code, and the exception will be pretty-printed, including the location (that's the case when Dune calls the driver). When the driver is spawned with the <code>-embed-errors</code> or <code>-as-ppx</code> flags (that's the case when Merlin calls the driver), the driver will look for located error. If it catches one, it will stop its rewriting chain at this point and output an AST consisting of the located error followed by the last valid AST: the one passed to the raising rewriter.</p><p>Even more in context-free rewriters, raising should be avoided in favour of outputting a single error node when finer grained reporting is not needed or possible. As the whole context-free rewriting is done in one traverse of the AST, a single raise will cancel both the context-free pass and upcoming rewriters, and the AST prior to the context-free pass will be outputted together with the error.</p><p>The function provided by the API to raise located errors is <a href="Ppxlib/Location/index.html#val-raise_errorf"><code>raise_errorf</code></a>.</p><h3 id="migrating-from-raising-to-embedding-errors"><a href="#migrating-from-raising-to-embedding-errors" class="anchor"></a>Migrating From Raising to Embedding Errors</h3><p>Lots of PPXs exclusively use <a href="Ppxlib/Location/index.html#val-raise_errorf"><code>raise_errorf</code></a> to report errors, instead of the more Merlin-friendly way of embedding errors in the AST, as described in this section.</p><p>If you want to migrate such a codebase to the embedding approach, the rest of this section will present few recipes to do that. It might not be completely trivial, as raising can be done anywhere in the code, including in places where &quot;embedding&quot; would not make sense. The first thing you can do is to turn your internal raising functions to function returning a <code>result</code> type.</p><p>The workflow for this change would look like this:</p><ol><li>Search your code for all uses of <a href="Ppxlib/Location/index.html#val-raise_errorf"><code>raise_errorf</code></a>, using <code>grep</code>, for instance.</li><li>For each of them, turn them into functions returning a <code>(_, extension) result</code> type, using <a href="Ppxlib/Location/index.html#val-error_extensionf"><code>error_extensionf</code></a> to generate the <code>Error</code>.</li><li>Let the compiler or Merlin tell you where to propagate the <code>result</code> type (most certainly using <code>map</code>s and <code>bind</code>s).</li><li>When you have propagated until a point where you can embed an extension node, turn the <code>Error</code> case into an extension node and embed it.</li></ol><p>This is quite convenient, as it allows you to do a &quot;type-driven&quot; modification, using the full static analysis of OCaml to never omit a special case and to confidently find the place the most deeply in the AST to embed the error. However, it might induce quite a lot of code modification, and exceptions are sometimes convenient to use depending on your preference. In case you want to do only a very simple change and keep using exception, just catch them at the right place and turn them into extension points embedded in the AST, as in the following example:</p><pre class="language-ocaml"><code>let rewrite_extension_point loc payload =
  try generate_ast payload
  with exn -&gt;
    let get_error exn =
      match Location.Error.of_exn exn with
      | None -&gt; raise exn
      | Some error -&gt; error
    in
    let extension = exn |&gt; get_error |&gt; Location.Error.to_extension in
    Ast_builder.Default.pstr_extension ~loc ext []</code></pre><h2 id="quoting"><a href="#quoting" class="anchor"></a>Quoting</h2><p>Quoting is part of producing <a href="https://en.wikipedia.org/wiki/Hygienic_macro">hygienic</a> code. But before talking about the solution, let's introduce the problem.</p><p>Say you are writing an extension rewriter, which takes an expression as payload, and would replace all identifiers <code>id</code> in the expression with a similar expression, but with a printing debug:</p><pre class="language-ocaml"><code>let x = 0 in
let y = 2 in
[%debug x + 1, y + 2 ]</code></pre><p>would generate the following code:</p><pre class="language-ocaml"><code>let x = 0 in
let y = 2 in
let debug = Printf.printf &quot;%s = %d; &quot; in
(debug &quot;x&quot; x ; x) + 1,
(debug &quot;y&quot; y ; y) + 2</code></pre><p>When executed, the code would print <code>x = 0; y = 2; </code>. So far, so good. However, suppose now that instead of <code>x</code>, the variable is named <code>debug</code>. The following seemingly equivalent code:</p><pre class="language-ocaml"><code>let debug = 0 in
let y = 2 in
[%debug debug + 1, y + 2 ]</code></pre><p>would generate:</p><pre class="language-ocaml"><code>let debug = 0 in
let y = 2 in
let debug = Printf.printf &quot;%s = %d; &quot; in
(debug &quot;debug&quot; debug ; debug) + 1,
(debug &quot;y&quot; y ; y) + 2</code></pre><p>which does not even type-check! The problem is that the payload is expected to be evaluated in some environment where <code>debug</code> has some value and type, but the rewriting modifies this environment and shadows the <code>debug</code> name.</p><p>&quot;Quoting&quot; is a mechanism to prevent this problem from happenning. In <code>ppxlib</code>, it is done through the <a href="Ppxlib/Expansion_helpers/Quoter/index.html"><code>Expansion_helpers.Quoter</code></a> module in several steps:</p><ul><li>First, create a quoter using the <a href="Ppxlib/Expansion_helpers/Quoter/index.html#val-create"><code>create</code></a> function:</li></ul><pre class="language-ocaml"><code># open Expansion_helper ;;
#s let quoter = Quoter.create () ;;
val quoter : Quoter.t = &lt;abstr&gt;</code></pre><ul><li>Then, use <a href="Ppxlib/Expansion_helpers/Quoter/index.html#val-quote"><code>Expansion_helpers.Quoter.quote</code></a> to quote all the expressions that are given from the user, might rely on a context, and that you want &quot;intact.&quot;</li></ul><pre class="language-ocaml"><code># let quoted_part = Quoter.quote quoter part_to_quote ;;
val quoted_payload : expression =</code></pre><ul><li>Finally, call <a href="Ppxlib/Expansion_helpers/Quoter/index.html#val-sanitize"><code>Expansion_helpers.Quoter.sanitize</code></a> on the whole expression (with quoted parts).</li></ul><pre class="language-ocaml"><code># let result = Expansion_helpers.Quoter.sanitize ~quoter rewritten_expression ;;
val result : expression =
...</code></pre><p>If the <code>debug</code> rewriter had been written using this method, the quoting would have ensured that the payload is evaluated in the same context as the extension node!</p><p>Here is an example on how to write a <code>debug</code> rewriter (with the limitation that the payload should not contain variable binding, but the code was left simple to illustrate quoting):</p><pre class="language-ocaml"><code># let rewrite expr =
    (* Create a quoter *)
    let quoter = Quoter.create () in
    (* An AST mapper to log and replace variables with quoted ones *)
    let replace_var =
      object
        (* See the chapter on AST traverse *)
        inherit Ast_traverse.map as super
  
        (* in case of expression *)
        method! expression expr =
          match expr.pexp_desc with
          (* in case of identifier (not &quot;+&quot;) *)
          | Pexp_ident { txt = Lident var_name; loc }
            when not (String.equal &quot;+&quot; var_name) -&gt;
              (* quote the var *)
              let quoted_var = Quoter.quote quoter expr in
              let name = Ast_builder.Default.estring ~loc var_name in
              (* and rewrite the expression *)
              [%expr
                debug [%e name] [%e quoted_var];
                [%e quoted_var]]
          (* otherwise, continue inside recursively *)
          | _ -&gt; super#expression expr
      end
    in
    let quoted_rewrite = replace_var#expression expr in
    let loc = expr.pexp_loc in
    (* Sanitize the whole thing *)
    Quoter.sanitize quoter
      [%expr
        let debug = Printf.printf &quot;%s = %d; &quot; in
        [%e quoted_rewrite]] ;;
  val rewrite : expression -&gt; expression = &lt;fun&gt;</code></pre><p>With <a href="Ppxlib/index.html"><code>Ppxlib</code></a>'s current quoting mechanism, the code given in that example would look like:</p><pre class="language-ocaml"><code># Format.printf &quot;%a\n&quot; Pprintast.expression @@ rewrite [%expr debug + 1, y + 2] ;;
let rec __1 = y
and __0 = debug in
let debug = Printf.printf &quot;%s = %d; &quot; in
(((debug &quot;debug&quot; __0; __0) + 1), ((debug &quot;y&quot; __1; __1) + 2))
- : unit = ()</code></pre><h2 id="testing-your-ppx"><a href="#testing-your-ppx" class="anchor"></a>Testing Your PPX</h2><p>This section is not yet written. You can refer to <a href="https://tarides.com/blog/2019-05-09-an-introduction-to-ocaml-ppx-ecosystem#testing-your-ppx">this blog post</a> (notice that that blog post was written before `dune` introduced its cram test feature), or contribute to the <code>ppxlib</code> documentation by opening a pull request in the <a href="https://github.com/ocaml-ppx/ppxlib/">repository</a>.</p><h2 id="migrate-from-other-preprocessing-systems"><a href="#migrate-from-other-preprocessing-systems" class="anchor"></a>Migrate From Other Preprocessing Systems</h2><p>This section is not yet written. You can contribute to the <code>ppxlib</code> documentation by opening a pull request in the <a href="https://github.com/ocaml-ppx/ppxlib/">repository</a>.</p><h2 id="other-good-practices"><a href="#other-good-practices" class="anchor"></a>Other good practices</h2><p>There are many good practices or other way to use <code>ppxlib</code> that are not mentioned in this manual. For instance, (in very short), you should always try to fully qualify variable names that are generated into the code via a PPX.</p><p>if you want to add a section to this &quot;good practices&quot; manual, you can contribute to the <code>ppxlib</code> documentation by opening a pull request in the <a href="https://github.com/ocaml-ppx/ppxlib/">repository</a>.</p><p> <div style="display: flex; justify-content:space-between"><div><a href="ast-traversal.html">&lt; Traversing the AST</a> </div><div><a href="examples.html">Examples &gt;</a> </div></div></p></div></body></html>